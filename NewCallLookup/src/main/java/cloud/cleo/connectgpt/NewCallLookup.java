package cloud.cleo.connectgpt;

import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.ConnectEvent;
import com.amazonaws.services.lambda.runtime.events.SNSEvent;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.time.LocalDate;
import java.time.ZoneId;
import java.util.HashMap;
import java.util.Map;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import software.amazon.awssdk.core.SdkSystemSetting;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbEnhancedClient;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbTable;
import software.amazon.awssdk.enhanced.dynamodb.Key;
import software.amazon.awssdk.enhanced.dynamodb.TableSchema;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedTimestampRecordExtension;
import software.amazon.awssdk.enhanced.dynamodb.model.QueryConditional;
import software.amazon.awssdk.regions.Region;
import software.amazon.awssdk.services.connect.ConnectClient;

/**
 * Receive a ConnectEvent via SNS
 *
 * @author sjensen
 */
public class NewCallLookup implements RequestHandler<SNSEvent, Void> {

    // Initialize the Log4j logger.
    Logger log = LogManager.getLogger(NewCallLookup.class);

    final static ConnectClient connect = ConnectClient.builder()
            .region(Region.of(System.getenv(SdkSystemSetting.AWS_REGION.environmentVariable())))
            .build();

    final static ObjectMapper mapper = new ObjectMapper();

    final static TableSchema<CallRecord> schema = TableSchema.fromBean(CallRecord.class);

    final static DynamoDbEnhancedClient enhancedClient = DynamoDbEnhancedClient.builder()
            .extensions(AutoGeneratedTimestampRecordExtension.create()).build();

    final static DynamoDbTable<CallRecord> calls = enhancedClient.table(System.getenv("CALLS_TABLE_NAME"), schema);

    
    static {
        mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
    }
    
    @Override
    public Void handleRequest(SNSEvent event, Context context) {
        try {
            log.debug(event);
            final var today = LocalDate.now(ZoneId.of("America/Chicago"));

            // Deserilize the event content into a ConnectEvent which was forwarded via SNS
            final ConnectEvent connEvent = mapper.readValue(event.getRecords().get(0).getSNS().getMessage(), ConnectEvent.class);

            log.debug("Connect Event is " + connEvent);

            // Phone Number for the caller 
            final var phoneNumber = connEvent.getDetails().getContactData().getCustomerEndpoint().getAddress();
            final var contactId = connEvent.getDetails().getContactData().getContactId();

            // Query for all items for this number
            var items = calls.query(QueryConditional.keyEqualTo(Key.builder()
                    .partitionValue(phoneNumber)
                    .build())).items();

            // Look for a call today
            var call = items.stream().filter(i -> i.getDate().equals(today)).findAny().orElse(null);

            final var recordCount = items.stream().count();
            log.debug("Record Count from Dynamo query is " + recordCount);

            if (call == null) {
                log.debug("First Call for today, creating CallRecord");
                // No call for today so create
                call = new CallRecord(connEvent);
            } else {
                log.debug("We have a current record for today");
            }

            // The number of calls in the last 60 days
            final var total_call_count = items.stream().mapToLong(c -> c.getCounter()).sum();
            log.debug("Total Calls in the Table is " + total_call_count);

            final Map<String, String> map = new HashMap<>();
            if (total_call_count > 0) {
                // they have called before
                map.put("PlayPrompt", "true");
                map.put("PlayPrompt-en-US", "Welcome Back");
                map.put("PlayPrompt-es-US", "Bienvenido de nuevo");
            }

            if (map.isEmpty()) {
                log.debug("No attributes to update, skipping Connect call to update Attrs");
            } else {
                try {
                    connect.updateContactAttributes((t) -> {
                        t.instanceId(connEvent.getDetails().getContactData().getInstanceArn())
                                .initialContactId(contactId)
                                .attributes(map);
                    });
                    // Make Serializable so we can turn to pretty JSON
                    //final var resSer = ser.getMapper().convertValue(res.toBuilder(), UpdateContactAttributesResponse.serializableBuilderClass());
                    //log.debug("Response from Update Contact Attributes is: " + ser.getMapper().valueToTree(resSer).toPrettyString());
                } catch (Exception e) {
                    log.error("Could Not Update Contact Center Attrs", e);
                }
            }

            // Log call for this contactID today
            call.addCall(contactId);
            calls.putItem(call);

        } catch (Exception e) {
            // Eat any exceptions, we don't want SNS re-tyring this lambda
            log.error(e);
        }
        return null;
    }

}
