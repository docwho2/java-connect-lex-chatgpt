/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Class.java to edit this template
 */
package cloud.cleo.connectgpt;

import com.amazonaws.services.lambda.runtime.Context;
import com.amazonaws.services.lambda.runtime.RequestHandler;
import com.amazonaws.services.lambda.runtime.events.LexV2Event;
import com.amazonaws.services.lambda.runtime.events.LexV2Event.DialogAction;
import com.amazonaws.services.lambda.runtime.events.LexV2Event.Intent;
import com.amazonaws.services.lambda.runtime.events.LexV2Event.SessionState;
import com.amazonaws.services.lambda.runtime.events.LexV2Response;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.theokanning.openai.completion.chat.ChatCompletionRequest;
import com.theokanning.openai.service.OpenAiService;
import java.net.SocketTimeoutException;
import java.time.LocalDate;
import java.time.ZoneId;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbEnhancedClient;
import software.amazon.awssdk.enhanced.dynamodb.DynamoDbTable;
import software.amazon.awssdk.enhanced.dynamodb.Key;
import software.amazon.awssdk.enhanced.dynamodb.TableSchema;
import software.amazon.awssdk.enhanced.dynamodb.extensions.AutoGeneratedTimestampRecordExtension;

/**
 *
 * @author sjensen
 */
public class ChatGPTLambda implements RequestHandler<LexV2Event, LexV2Response> {

    // Initialize the Log4j logger.
    Logger log = LogManager.getLogger();
    
    final static ObjectMapper mapper = new ObjectMapper();

    final static TableSchema<ChatGPTSessionState> schema = TableSchema.fromBean(ChatGPTSessionState.class);

    final static DynamoDbEnhancedClient enhancedClient = DynamoDbEnhancedClient.builder()
            .extensions(AutoGeneratedTimestampRecordExtension.create()).build();

    final static DynamoDbTable<ChatGPTSessionState> sessionState = enhancedClient.table(System.getenv("SESSION_TABLE_NAME"), schema);

    final static OpenAiService open_ai_service = new OpenAiService(System.getenv("OPENAI_API_KEY"));
    final static String OPENAI_MODEL = System.getenv("OPENAI_MODEL");

    @Override
    public LexV2Response handleRequest(LexV2Event lexRequest, Context cntxt) {
        try {
            log.debug(mapper.valueToTree(lexRequest).toString());
            final var intentName = lexRequest.getSessionState().getIntent().getName();
            log.debug("Intent: " + intentName);
            return processGPT(lexRequest);
        } catch (Exception e) {
            log.error(e);
            // Unhandled Exception
            if ("es_US".equalsIgnoreCase(lexRequest.getBot().getLocaleId())) {
                return buildResponse(lexRequest, "Lo siento, tengo un problema para cumplir con su solicitud. Es posible que el chat GPT esté inactivo. Vuelva a intentarlo más tarde.");
            } else {
                return buildResponse(lexRequest, "Sorry, I'm having a problem fulfilling your request.  Chat GPT might be down, Please try again later.");
            }
        }
    }

    private LexV2Response processGPT(LexV2Event lexRequest) {

        final var input = lexRequest.getInputTranscript();
        final var localId = lexRequest.getBot().getLocaleId();

        log.debug("Language is [" + localId + "]");

        if (input == null || input.isBlank()) {
            log.debug("Got blank input, so just silent or nothing");
            // If we get slience (timeout without speech), then we get empty string on the transcripp
            if ("es_US".equalsIgnoreCase(localId)) {
                return buildResponse(lexRequest, "Lo siento, no entendí eso, si terminaste, simplemente dime adiós, de lo contrario, dime cómo puedo ayudarte.");
            } else {
                return buildResponse(lexRequest, "I'm sorry, I didn't catch that, if your done, simply say good by, otherwise tell me how I can help");
            }
        }

        // When testing in lex console input will be text, so use session ID, for speech we shoud have a phone via Connect
        final var user_id = "Text".equalsIgnoreCase(lexRequest.getInputMode()) ? lexRequest.getSessionId()
                : lexRequest.getSessionState().getSessionAttributes().get("CustomerNumber");

        // Key to record in Dynamo
        final var key = Key.builder().partitionValue(user_id).sortValue(LocalDate.now(ZoneId.of("America/Chicago")).toString()).build();

        //  load session state if it exists
        log.debug("Start Retreiving Session State");
        var session = sessionState.getItem(key);
        log.debug("End Retreiving Session State");

        if (session == null) {
            session = new ChatGPTSessionState(user_id, localId);
        }

        // add this request to the session
        session.addUserMessage(input);

        String botResponse;
        try {

            ChatCompletionRequest request = ChatCompletionRequest.builder()
                    .messages(session.getChatMessages())
                    .model(OPENAI_MODEL)
                    .maxTokens(500)
                    .temperature(0.2) // More focused
                    .n(1) // Only return 1 completion
                    .build();

            log.debug("Start API Call to ChatGPT");
            final var completion = open_ai_service.createChatCompletion(request);
            log.debug("End API Call to ChatGPT");
            log.debug(completion);

            botResponse = completion.getChoices().get(0).getMessage().getContent();

            // Add response to session
            session.addAssistantMessage(botResponse);

            // Save the session to dynamo
            log.debug("Start Saving Session State");
            session.incrementCounter();
            sessionState.putItem(session);
            log.debug("End Saving Session State");
        } catch (RuntimeException rte) {
            if (rte.getCause() != null && rte.getCause() instanceof SocketTimeoutException) {
                log.error("Response times out", rte);
                if ("es_US".equalsIgnoreCase(localId)) {
                    botResponse = "Se agotó el tiempo de espera de la operación, vuelva a hacer su pregunta";
                } else {
                    botResponse = "The operation timed out, please ask your question again";
                }
            } else {
                throw rte;
            }
        }

        return buildResponse(lexRequest, botResponse);
    }

    /**
     * All responses are EllicitIntent with plain text
     *
     * @param lexRequest
     * @param response
     * @return
     */
    private LexV2Response buildResponse(LexV2Event lexRequest, String response) {
        // Start with Orginal State
        final var os = lexRequest.getSessionState();
        
        // Incoming Intent
        final var requestIntent = os.getIntent();
        
        // State to return
        final var ss = SessionState.builder()
                // Retain the current session attributes
                .withSessionAttributes(os.getSessionAttributes())
                // Send back clean intent without any states
                .withIntent(Intent.builder().withName(requestIntent.getName()).withSlots(requestIntent.getSlots()).build())
                // Always ElictIntent, so you're back at the LEX Bot fresh again
                .withDialogAction(DialogAction.builder().withType("ElicitIntent").build())
                .build();
        
        final var lexV2Res = LexV2Response.builder()
                .withSessionState(ss)
                // We are using plain text responses
                .withMessages(new LexV2Response.Message[]{new LexV2Response.Message("PlainText", response, null)})
                .build();
        log.debug("Response is " + mapper.valueToTree(lexV2Res));
        return lexV2Res;
    }
}
